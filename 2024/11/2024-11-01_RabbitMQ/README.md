# RabbitMQ

오늘은 면접시 매번 질문 받았던 메시지 큐 중 RabbitMQ에 대해 작성해보려 한다.   
RabbitMQ는 메시지 큐(MQ)를 통해 애플리케이션 간 데이터를 비동기적으로 전달하는 **메시지 브로커**이다. 분산 시스템의 복잡성을 줄이고, 비동기 메시징을 통해 각 시스템이 느슨하게 결합되어 확장성과 유연성이 높아지도록 돕는다. 메시지를 송신하는 **생산자(Producer)**와 이를 수신하는 **소비자(Consumer)** 사이의 중개자 역할을 하며, 특정 조건에 따라 메시지를 필터링하고 라우팅할 수 있다.

## 1. RabbitMQ 개요

RabbitMQ는 AMQP(Advanced Message Queuing Protocol)를 기반으로 작동하며, 다양한 유형의 **Exchange**와 **Queue**를 사용해 메시지 흐름을 유연하게 설정할 수 있다. 이를 통해 메시지를 다방향으로 라우팅하고, 여러 큐와 소비자 사이에서 메시지를 효율적으로 분배한다.

### RabbitMQ의 주요 개념 및 용어

- **Producer (생산자)**: 큐에 메시지를 생성하고 전송하는 역할을 하며, 데이터를 다른 서비스나 애플리케이션에 전달하고자 할 때 사용된다.
  
- **Consumer (소비자)**: 큐로부터 메시지를 받아 처리하는 역할을 하며, 주로 특정 작업을 수행하거나 다른 시스템으로 데이터를 전달할 때 사용된다.

- **Queue (큐)**: 메시지를 일시적으로 저장하는 공간으로, 여러 소비자가 동시에 큐의 메시지를 처리할 수 있다. 큐는 FIFO(First In, First Out) 방식으로 동작하며, `durable` 옵션을 통해 영구적으로 메시지를 저장할 수 있다.

- **Exchange (교환기)**: 생산자가 보낸 메시지를 특정 큐로 분배하는 역할을 한다. RabbitMQ는 다양한 유형의 Exchange를 제공하며, 메시지의 목적지(큐)를 결정하는 핵심 요소다.
  - **Direct Exchange**: 메시지와 큐의 라우팅 키가 일치하는 큐로만 메시지를 전달한다.
  - **Fanout Exchange**: 모든 큐로 메시지를 브로드캐스트 방식으로 전달한다.
  - **Topic Exchange**: 와일드카드 문자를 활용하여 특정 주제에 맞는 큐로 메시지를 전달한다.
  - **Headers Exchange**: 메시지의 헤더 값에 따라 특정 조건을 만족하는 큐로 전달한다.

- **Binding (바인딩)**: Exchange와 Queue를 연결해, 메시지를 특정 규칙에 맞게 라우팅할 수 있도록 설정하는 것. Binding을 통해 다양한 라우팅 전략을 구현할 수 있다.

## 2. RabbitMQ의 주요 사용 사례

RabbitMQ는 비동기 작업이 필요한 다양한 사례에서 유용하게 사용된다. 이를 통해 시스템의 응답성을 개선하고, 비동기 작업을 효과적으로 분산하여 처리할 수 있다.

- **작업 큐 (Task Queue)**  
  RabbitMQ를 사용해 긴 작업을 비동기적으로 처리할 수 있다. 예를 들어, 대용량 파일 처리, 데이터 변환, 이메일 발송과 같은 작업을 큐에 저장하고 비동기로 처리함으로써, 애플리케이션의 응답 속도를 높이고 메인 프로세스에 부담을 덜어준다.

- **서비스 간 통신**  
  RabbitMQ는 서비스 간 통신을 비동기화함으로써, 서비스의 독립성과 확장성을 유지하면서도 데이터 전달과 작업 조율을 수행할 수 있다. 예를 들어 주문 시스템과 결제 시스템 간 메시지 전달에 RabbitMQ를 사용하여 비동기 통신을 구현할 수 있다.

- **실시간 이벤트 스트리밍**  
  RabbitMQ를 사용해 실시간 데이터 흐름을 관리할 수 있다. 예를 들어, 주문 상태 변경, 사용자 활동 로그 등의 실시간 이벤트를 다른 시스템으로 전달하여 모니터링 및 분석에 활용할 수 있다.

- **로드 밸런싱과 작업 분배**  
  여러 소비자가 동일한 큐를 소비하도록 설정하면, 큐에 쌓인 작업을 분산하여 처리할 수 있다. 이로 인해 작업 처리 성능이 개선되고, 소비자 간 로드가 균등하게 분배된다. RabbitMQ는 소비자 간 작업 분배를 통해 시스템 성능과 안정성을 높일 수 있다.

## 3. RabbitMQ의 장점

- **비동기 메시징 지원**  
  RabbitMQ는 메시지를 비동기적으로 처리하여 애플리케이션의 응답성을 향상시키며, 작업 큐에서 처리해야 할 메시지가 많아도 메인 애플리케이션의 처리가 지연되지 않는다.

- **유연한 라우팅 기능**  
  다양한 Exchange 타입을 통해 메시지를 특정 큐로 라우팅할 수 있다. 이로 인해 메시지 전달 방식에 유연성을 제공하고, 특정 메시지를 특정 소비자에게만 전달하는 등 다양한 시나리오를 구현할 수 있다.

- **메시지 보장**  
  메시지를 디스크에 영구적으로 저장하여, 서버 재시작이나 장애 발생 시에도 메시지를 손실하지 않고 보관할 수 있다. `durable` 옵션을 통해 메시지를 영구 큐에 저장해 장애 상황에서도 데이터 손실을 최소화할 수 있다.

- **확장성과 고가용성**  
  RabbitMQ는 클러스터링을 통해 여러 노드에 큐와 메시지를 분산할 수 있어, 대규모 트래픽을 효과적으로 처리하고 고가용성을 확보할 수 있다. 또한, 클러스터링을 통해 노드 장애 발생 시에도 메시지 전달을 지속할 수 있다.

## 4. 트러블슈팅 경험: 메시지 손실 문제 해결

RabbitMQ를 통한 비동기 작업 분배 과정에서 예상치 못한 메시지 손실 문제가 발생했다. RabbitMQ 서버가 재시작될 때나 네트워크 장애가 발생한 경우, 큐에 있던 메시지가 유실되는 현상이 나타났다.

### 문제 원인
메시지를 `durable` 설정 없이 메모리에만 저장했기 때문에, 서버가 재시작되면 메모리에 있는 메시지가 삭제되는 상황이 발생했다. 또한, `ack` 설정이 없었기 때문에 소비자가 정상적으로 메시지를 처리하지 못했을 경우에도 메시지 손실이 발생했다.

### 해결 방법
1. **Durable Queue 설정**: 큐를 `durable`로 설정하여 메시지가 디스크에 저장되도록 구성했다. 이 설정을 통해 서버 재시작 후에도 메시지가 유지될 수 있게 했다.

2. **Persistent 메시지 설정**: 메시지를 `persistent`로 설정하여, 큐에 저장된 메시지가 디스크에 기록되도록 했다. 이로 인해 네트워크 문제나 서버 장애가 발생하더라도 메시지가 손실되지 않도록 보장할 수 있었다.

3. **Ack 설정 추가**: 메시지 소비 시 `ack`를 활성화하여 메시지가 성공적으로 처리되었을 때만 RabbitMQ에서 메시지를 제거하도록 설정했다. 소비자가 메시지 처리에 실패할 경우 해당 메시지는 다시 큐에 남아 다른 소비자가 처리할 수 있도록 했다.

4. **Dead Letter Queue 구성**: 처리 실패한 메시지를 다른 큐(Dead Letter Queue)에 저장하여 문제 메시지를 추적하고, 이를 통해 문제가 되는 데이터를 별도로 관리하도록 설정했다.

### 결과
이러한 설정을 통해 RabbitMQ가 재시작되거나 네트워크 장애가 발생하더라도 메시지가 안전하게 유지되었고, 작업 큐의 신뢰성과 안정성이 크게 개선되었다. `durable`과 `persistent` 설정을 통해 메시지 보존을 강화하고, `ack`와 Dead Letter Queue를 통해 메시지 처리 신뢰성을 확보할 수 있었다.

## 결론
메시지 큐는 면접 시 자주 질문되는 주제 중 하나로, 그중 내가 사용했던 RabbitMQ를 정리해봤다. (Kafka, Amazon SQS 등 여러 기술이 있으나, 사용해보지 않아 추후 사용하게 되면 작성해야겠다.) RabbitMQ는 비동기 작업 처리와 데이터 전달을 효율적으로 관리할 수 있는 중요한 메시지 브로커이다. 특히 작업을 큐에 쌓아 처리함으로써 애플리케이션의 성능을 최적화하고, 시스템의 확장성을 높일 수 있는 점에서 큰 장점을 지닌다. 메시지의 안정적인 전달, 다양한 라우팅 옵션, 그리고 빠른 데이터 처리를 지원하여, 분산 시스템이나 대용량 처리 환경에서 유용하게 활용할 수 있다.